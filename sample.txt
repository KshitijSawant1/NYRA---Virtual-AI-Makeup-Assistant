import streamlit as st
import cv2
import numpy as np
import mediapipe as mp

# Initialize Mediapipe Face Mesh
mp_face_mesh = mp.solutions.face_mesh
face_mesh = mp_face_mesh.FaceMesh(static_image_mode=False, max_num_faces=1, refine_landmarks=True)

# Define Facial Landmarks
LEFT_CHEEK_CONTOUR = [234, 93, 132, 58, 172, 136, 150]
RIGHT_CHEEK_CONTOUR = [454, 323, 361, 288, 397, 365, 379]
UPPER_LIP = [61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, 308, 415, 310, 312, 13, 82, 81, 80, 191, 78]
LOWER_LIP = [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 308, 324, 402, 317, 14, 87, 178, 88, 95, 78, 61]
LEFT_EYESHADOW = [226, 247, 30, 29, 27, 28, 56, 190, 243, 173, 157, 158, 159, 160, 161, 246, 33, 130, 226]
RIGHT_EYESHADOW = [463, 414, 286, 258, 257, 259, 260, 467, 446, 359, 263, 466, 388, 387, 386, 385, 384, 398, 362, 463]

# Streamlit UI
st.title("üíÑ Virtual Makeup App (Blush, Lipstick & Eyeshadow)")
st.sidebar.title("üé® Makeup Settings")

# Blush Settings
opacity_blush = st.sidebar.slider("üå∏ Blush Intensity", 0.1, 1.0, 0.5)
blush_color_mode = st.sidebar.radio("Blush Color Mode", ["Match Skin Tone", "Custom Color"])
if blush_color_mode == "Custom Color":
    blush_color = st.sidebar.color_picker("Choose Blush Color", "#FF69B4")

# Lipstick Settings
lipstick_color = st.sidebar.color_picker("üíã Lipstick Color", "#FF0000")
lipstick_opacity = st.sidebar.slider("üíÑ Lipstick Intensity", 0.1, 1.0, 0.6)

# Eyeshadow Settings
left_eyeshadow_color = st.sidebar.color_picker("üëÅÔ∏è Left Eyeshadow Color", "#FF69B4")
right_eyeshadow_color = st.sidebar.color_picker("üëÅÔ∏è Right Eyeshadow Color", "#9370DB")
eyeshadow_opacity = st.sidebar.slider("üëÅÔ∏è Eyeshadow Intensity", 0.1, 1.0, 0.6)

# Convert Hex Color to BGR
def hex_to_bgr(hex_color):
    hex_color = hex_color.lstrip("#")
    r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
    return (b, g, r)

# Function to get average skin tone from contour points
def get_average_skin_tone(frame, points):
    mask = np.zeros(frame.shape[:2], dtype=np.uint8)
    cv2.fillPoly(mask, [np.array(points, dtype=np.int32)], 255)
    mean_val = cv2.mean(frame, mask=mask)
    return (int(mean_val[0]), int(mean_val[1]), int(mean_val[2]))  # Return BGR values

# Enable Webcam
use_webcam = st.sidebar.checkbox("üì∑ Enable Webcam")
FRAME_WINDOW = st.image([])

if use_webcam:
    cap = cv2.VideoCapture(0)

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            st.error("‚ùå Could not access the webcam.")
            break

        # Convert frame to RGB for Mediapipe processing
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = face_mesh.process(frame_rgb)

        if results.multi_face_landmarks:
            for face_landmarks in results.multi_face_landmarks:
                h, w, _ = frame.shape
                blush_overlay = frame.copy()
                mask = np.zeros_like(frame, dtype=np.uint8)

                # -------- Apply Blush -------- #
                left_cheek_points = np.array(
                    [[int(face_landmarks.landmark[i].x * w), int(face_landmarks.landmark[i].y * h)]
                     for i in LEFT_CHEEK_CONTOUR], np.int32)
                right_cheek_points = np.array(
                    [[int(face_landmarks.landmark[i].x * w), int(face_landmarks.landmark[i].y * h)]
                     for i in RIGHT_CHEEK_CONTOUR], np.int32)

                if blush_color_mode == "Match Skin Tone":
                    left_cheek_color = get_average_skin_tone(frame, left_cheek_points)
                    right_cheek_color = get_average_skin_tone(frame, right_cheek_points)
                else:
                    left_cheek_color = hex_to_bgr(blush_color)
                    right_cheek_color = hex_to_bgr(blush_color)

                cv2.fillPoly(blush_overlay, [left_cheek_points], left_cheek_color)
                cv2.fillPoly(blush_overlay, [right_cheek_points], right_cheek_color)
                blush_overlay = cv2.GaussianBlur(blush_overlay, (35, 35), 10)
                mask_blush = np.zeros_like(frame, dtype=np.uint8)
                cv2.fillPoly(mask_blush, [left_cheek_points], (255, 255, 255))
                cv2.fillPoly(mask_blush, [right_cheek_points], (255, 255, 255))
                mask_blush = cv2.GaussianBlur(mask_blush, (35, 35), 10)
                mask_blush = mask_blush.astype(float) / 255

                for c in range(3):
                    frame[:, :, c] = frame[:, :, c] * (1 - mask_blush[:, :, c] * opacity_blush) + blush_overlay[:, :, c] * (mask_blush[:, :, c] * opacity_blush)

                # -------- Apply Lipstick -------- #
                upper_lip_points = np.array(
                    [[int(face_landmarks.landmark[i].x * w), int(face_landmarks.landmark[i].y * h)]
                     for i in UPPER_LIP], np.int32)
                lower_lip_points = np.array(
                    [[int(face_landmarks.landmark[i].x * w), int(face_landmarks.landmark[i].y * h)]
                     for i in LOWER_LIP], np.int32)

                lipstick_bgr = hex_to_bgr(lipstick_color)
                cv2.fillPoly(mask, [upper_lip_points], lipstick_bgr)
                cv2.fillPoly(mask, [lower_lip_points], lipstick_bgr)

                # -------- Apply Eyeshadow -------- #
                left_eyeshadow_points = np.array(
                    [[int(face_landmarks.landmark[i].x * w), int(face_landmarks.landmark[i].y * h)]
                     for i in LEFT_EYESHADOW], np.int32)
                right_eyeshadow_points = np.array(
                    [[int(face_landmarks.landmark[i].x * w), int(face_landmarks.landmark[i].y * h)]
                     for i in RIGHT_EYESHADOW], np.int32)

                left_eye_bgr = hex_to_bgr(left_eyeshadow_color)
                right_eye_bgr = hex_to_bgr(right_eyeshadow_color)

                cv2.fillPoly(mask, [left_eyeshadow_points], left_eye_bgr)
                cv2.fillPoly(mask, [right_eyeshadow_points], right_eye_bgr)

                # -------- Blend Everything -------- #
                frame = cv2.addWeighted(frame, 1, mask, lipstick_opacity, 0)
                frame = cv2.addWeighted(frame, 1, mask, eyeshadow_opacity, 0)

        # Convert frame to RGB for display
        display_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        FRAME_WINDOW.image(display_frame)

    cap.release()
else:
    st.info("üëÜ Enable the webcam from the sidebar to start the feed.")
